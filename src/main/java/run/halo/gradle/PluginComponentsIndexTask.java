package run.halo.gradle;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.LinkedHashSet;
import java.util.Set;
import lombok.extern.slf4j.Slf4j;
import org.gradle.api.Project;
import org.gradle.api.artifacts.ResolvableDependencies;
import org.gradle.api.file.ConfigurableFileCollection;
import org.gradle.api.file.FileCollection;
import org.gradle.api.provider.Provider;
import org.gradle.api.tasks.InputFiles;
import org.gradle.api.tasks.TaskAction;
import org.gradle.jvm.tasks.Jar;
import org.objectweb.asm.ClassReader;
import run.halo.gradle.utils.AsmConst;

@Slf4j
public class PluginComponentsIndexTask extends Jar {

    private final String mainClass = "run.halo.app.plugin.BasePlugin";

    private final Provider<String> projectName;

    private final Provider<Object> projectVersion;

    private final PluginArchiveSupport support;

    private FileCollection classpath;

    /**
     * The package separator character: {@code '.'}.
     */
    private static final char PACKAGE_SEPARATOR = '.';

    /**
     * The path separator character: {@code '/'}.
     */
    private static final char PATH_SEPARATOR = '/';

    private static final String CLASS_SUFFIX = ".class";
    private static final String FILEPATH = "META-INF/plugin-components.idx";

    public static final String TASK_NAME = "generatePluginComponentsIdx";

    /**
     * Creates a new {@code BootJar} task.
     */
    public PluginComponentsIndexTask() {
        this.support = new PluginArchiveSupport(mainClass);
        Project project = getProject();
        project.getConfigurations().all((configuration) -> {
            ResolvableDependencies incoming = configuration.getIncoming();
            incoming.afterResolve((resolvableDependencies) -> {
                if (resolvableDependencies == incoming) {
                    //this.resolvedDependencies.processConfiguration(project, configuration);
                }
            });
        });
        this.projectName = project.provider(project::getName);
        this.projectVersion = project.provider(project::getVersion);
    }

    @InputFiles
    ConfigurableFileCollection classesDirs = getProject().getObjects().fileCollection();


    @Override
    public void copy() {
        // this.support.configureManifest(getManifest(), getMainClass().get(), CLASSES_DIRECTORY,
        //     LIB_DIRECTORY,
        //     CLASSPATH_INDEX, (isLayeredDisabled()) ? null : LAYERS_INDEX,
        //     this.getTargetJavaVersion().get().getMajorVersion(), this.projectName.get(),
        //     this.projectVersion.get());
        // super.copy();
    }

    @TaskAction
    public void generate() throws IOException {
        log.info("Generating plugin components index file...");

        String buildPath = classesDirs.getAsPath();
        Set<String> componentsIdxFileLines = new LinkedHashSet<>();
        componentsIdxFileLines.add("# Generated by Halo");
        for (File file : classesDirs.getAsFileTree()) {
            if (!file.getName().endsWith(CLASS_SUFFIX)) {
                continue;
            }

            ClassReader classReader = new ClassReader(new FileInputStream(file));
            FilterComponentClassVisitor filterComponentClassVisitor =
                new FilterComponentClassVisitor(AsmConst.ASM_VERSION);
            classReader.accept(filterComponentClassVisitor, ClassReader.SKIP_DEBUG);

            if (filterComponentClassVisitor.isComponentClass()) {
                String className =
                    convertResourcePathToClassName(filterComponentClassVisitor.getName());
                componentsIdxFileLines.add(className);
            }
        }
        // write to file
        Path componentsIdxPath = Paths.get(buildPath).resolve(FILEPATH);
        if (!Files.exists(componentsIdxPath.getParent())) {
            Files.createDirectories(componentsIdxPath.getParent());
        }
        if (!Files.exists(componentsIdxPath)) {
            Files.createFile(componentsIdxPath);
        }
        Files.write(componentsIdxPath, componentsIdxFileLines, StandardCharsets.UTF_8);
    }

    public ConfigurableFileCollection getClassesDirs() {
        return classesDirs;
    }


    /**
     * Convert a "/"-based resource path to a "."-based fully qualified class name.
     *
     * @param resourcePath the resource path pointing to a class
     * @return the corresponding fully qualified class name
     */
    public static String convertResourcePathToClassName(String resourcePath) {
        Assert.notNull(resourcePath, "Resource path must not be null");
        return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);
    }
}
